执行环境 
每调用一个函数时（执行函数时），系统会为该函数创建一个封闭的局部的运行环境，
即该函数的执行环境。函数总是在自己的执行环境中执行，如读写局部变量、 函数参数、运行内部逻辑。
创建执行环境的过程包含了创建函数的作用域，函数也是在自己的作用域下执行的。
从另一个角度说，每个函数执行环境都有一个作用域 链，子函数的作用域链包括它的父函数的作用域链。

作用域链 
简单来说,作用域链就是函数在定义的时候创建的,用于寻找使用到的变量的值的一个索引,
而他内部的规则是,把函数自身的本地变量放在最前面,把自身的父级 
函数中的变量放在其次,把再高一级函数中的变量放在更后面,以此类推直至全局对象为止.
当函数中需要查询一个变量的值的时候,js解释器会去作用域链去查 找,
从最前面的本地变量中先找,如果没有找到对应的变量,则到下一级的链上找,
一旦找到了变量,则不再继续.如果找到最后也没找到需要的变量,
则解释器返 回undefined。

垃圾回收机制 
一般来说,一个函数在执行开始的时候,会给其中定义的变量划分内存空间保存,
以备后面的语句所用,等到函数执行完毕返回了,这些变量就被认为是无用的了. 
对应的内存空间也就被回收了.下次再执行此函数的时候,所有的变量又回到最初的状态,
重新赋值使用.但是如果这个函数内部又嵌套了另一个函数,
而这个函数是有可能在外部被调用到的.并且这个内部函数又使用了外部函数的某些变量的话.
这种内存回收机制就会出现问题.如果在外部函数返回后,又直接调用了内部函 数,
那么内部函数就无法读取到他所需要的外部函数中变量的值了.
所以js解释器在遇到函数定义的时候,会自动把函数和他可能使用的变量
(包括本地变量和父 级和祖先级函数的变量(自由变量))一起保存起来.
也就是构建一个闭包,这些变量将不会被内存回收器所回收,
只有当内部的函数不可能被调用以后(例如被删 除了,或者没有了指针),
才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收.
重点：只有当内部的函数不可能被调用以后(例如被删 除了,或者没有了指针),
才会销毁这个闭包,而没有任何一个闭包引用的变量才会被下一次内存回收启动时所回收.

function f1(){
　　　　var n=999;
　　　　nAdd=function(){n+=1}
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000
在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，
第二次的值是1000。这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。 
为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，
这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，
被垃圾回收机制回收。